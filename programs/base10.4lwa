label toBase10
    preserve A B C
    MV [stack S] [reg A] # The number
    MV [const 0] [reg C] # Length counter

    # This algorithm won't work if the number is zero.
    JZ [reg A] [const :_base_num_is_zero]

    loop {
        JZ [reg A] [const :_baseloopend]
        MD [reg A] [const 10] [reg B] # A mod 10
        AD [reg B] [const __N_] [reg B] # make it a number char
        MV [reg B] [stack V] # We have a digit, save it
        MV [reg inc C] [reg C] # Inc C
        DV [reg A] [const 10] [reg A] # The new A
    }

    label _baseloopend

    MV [reg C] [stack V] # Top of stack is number of values.
    restore C B A
    RT

    label _base_num_is_zero # What to do if number is zero:
    MV [const __N_] [stack V] # Repr of zero
    MV [const 1] [reg C] # One value
    JP [const :_baseloopend] # Jump to end

function printBase10 preserving A B C{
    FN [const :toBase10] [stack S]
    MV [stack V] [reg C] # Length of number

    loop {
        JZ [reg C] [const :_printBaseEnd] # If no more numbers, exit
        MV [stack V] [io]           # Print the number
        MV [reg dec C] [reg C]          # decrement
    }

    label _printBaseEnd
}
