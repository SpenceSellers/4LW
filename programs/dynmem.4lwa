reserve dynamic_start 1

function dynmemInit {
    MV [const B___] [const mem :dynamic_start]
    call setUnallocated [const mem :dynamic_start]
    call setTagLen [const mem :dynamic_start] [const 100]

    call nextTag [const mem :dynamic_start]
    MV [const ZZZZ] [stack mem V]
}

function tagOfMem {
    SB [stack S] [const 4] [stack V]
}

function memOfTag {
    AD [stack S] [const 4] [stack V]
}

# (Tag addr) -- (Tag Addr)
function nextTag preserving A {
    MV [stack S] [reg A]
    call getTagLen [reg A]
    call memOfTag [reg A]
    AD [stack V] [stack timesfour V] [stack V]

}

# (Tag addr) -- (length (words))
function getTagLen {
    AN [stack mem S] [const _AAA] [stack V]
}

# (Tag addr) (Length in words, max ZZZ) --
function setTagLen preserving A B {
    MV [stack S] [reg B] # Len
    MV [stack S] [reg A] # Tag addr
    AN [reg mem A] [const A___] [reg mem A] # Mask out lower three letters
    AD [reg mem A] [reg B] [reg mem A]
}

# (Tag addr) --
function setAllocated {
    call setTagFlag [stack S] [const A]
}

# (Tag addr) --
function setUnallocated {
    call setTagFlag [stack S] [const U]
}

# (Tag word) -- Bool
function isAllocated {
    JE [stack first mem S] [const U] [const :unalloc]
    MV [const ZZZZ] [stack V]
    JP [const :@return]

    label unalloc
    MV [const 0] [stack V]
}

function isTagStop {
    JE [stack first mem S] [const Z] [const :yes]
    MV [const 0] [stack V]
    JP [const :@return]

    label yes
    MV [const ZZZZ] [stack V]
}

# (Tag addr) (Flag letter) --
function setTagFlag preserving A B {
    MV [stack S] [reg B] # Flag
    MV [stack S] [reg A] # Tag addr
    AN [reg mem A] [const _AAA] [reg mem A]
    ML [reg B] [const A___] [reg B]
    AD [reg mem A] [reg B] [reg mem A]
}

# (Length in words) -- (Mem addr)
function malloc preserving A B C {
    MV [stack S] [reg B] # Length we want to reserve.
    MV [const mem :dynamic_start] [reg A] # Tag we're at.

    loop {
        call isTagStop [reg A] # Out of space
        JZ [stack neg V] [const :outOfSpace]

        call isAllocated [reg A]
        JZ [stack neg V] [const :next] # It's allocated, move on

        call getTagLen [reg A] to [reg C] # Temporarily store old length in C
        call printWord [reg B]
        call printWord [reg C]
        call printNewline
        JG [reg inc B] [reg C] [const :next] # Too short. Inc is for the tag.

        # We've found the tag we're going to use.

        # Modify our unallocated tag.
        call setTagLen [reg A] [reg B]
        call setAllocated [reg A]

        SB [reg C] [reg inc B] [reg B] # B now contains the NEXT tag's length.

        # Set up the next tag.
        call nextTag [reg A] to [reg C] # C is the new tag.
        call setUnallocated [reg C]
        call setTagLen [reg C] [reg B]

        call memOfTag [reg A] to [stack V]
        JP [const :@return]


        label next
        call nextTag [reg A] to [reg A]
    }
    label outOfSpace
    MV [const ZZZZ] [stack V]
}

function free {
    call tagOfMem [stack S]
    call setUnallocated [stack V]
}

function debugHeap preserving A B {
    MV [const mem :dynamic_start] [reg A]
    loop {
        MV [reg first mem A] [reg B]
        call isTagStop [reg A]
        JE [stack V] [const ZZZZ] [const :@return]
        call memOfTag [reg A]
        call getTagLen [reg A]

        call printf [stack V] [reg B] [stack V] [reg A] [const :describe_node_str]

        call nextTag [reg A] to [reg A]
    }
}

term_string describe_node_str "Tag %w Region %w flag %c length %w%n"
