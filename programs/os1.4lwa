JP [const :start]

import dynmem.4lwa
import print.4lwa
import strings.4lwa
import base10.4lwa

array command_strs :poke_str :peek_str :base27_str :base10_str :coredump_str :write_str :jump_str :echo_str :memdebug_str :memdefrag_str :runinst_str :alloc_str ZZZZ
array command_fns :poke_cmd :peek_cmd :base27_cmd :base10_cmd :coredump_cmd :write_cmd :jump_cmd :echo_cmd :memdebug_cmd :memdefrag_cmd :runinst_cmd :alloc_cmd ZZZZ
label start

call dynmemInit [const B___] [const ET__]

#call debugHeap

call printf [const :welcome_str]
SB [const ZZZZ] [const :@end] [reg M]
call printBase10 [reg M]
call printf [const :freemem_str]

label commandLine

loop {
    call printNewline
    call printTerminated [const :entercmd_str]
    call readLineTerm [const :cmd_buffer] [const 10]
    MV [const 0] [reg A]
    loop {
        AD [const :command_strs] [reg timesfour A] [reg B]
        JZ [reg neg mem B] [const :badcmd]
        call strEq [const :cmd_buffer] [reg mem B]
        JZ [stack V] [const :next]
        AD [const :command_fns] [reg timesfour A] [reg B]
        FN [reg mem B]
        JP [const :commandLine]

        label next
        MV [reg inc A] [reg A]
    }

    label badcmd
    call printTerminated [const :badcmd_str]
    call printNewline
}

function poke_cmd preserving A B {
    call printTerminated [const :address_str]
    call readWord to [reg A]
    call printNewline
    call readWord to [reg B]
    MV [reg B] [reg mem A]
}

function peek_cmd {
    call printTerminated [const :address_str]
    call readWord
    call printNewline
    MV [stack mem V] [stack S]
    call printWord [stack S]
}

function base27_cmd {
    call readBase10Line
    call printWord [stack V]
}

function base10_cmd {
    call readWord
    call printNewline
    call printBase10 [stack V]
}

function coredump_cmd preserving A B {
    call printTerminated [const :address_str]
    call readWord to [reg A]
    call printNewline
    call printTerminated [const :address_str]
    call readWord to [reg B]
    call printNewline
    call coreDump [reg A] [reg B]
}

function write_cmd preserving A {
    call printTerminated [const :address_str]
    call readWord to [reg A]
    call printNewline
    call enterRaw [reg A]
}

function jump_cmd {
    call printTerminated [const :address_str]
    call readWord
    call printNewline
    JP [stack V]
}

function echo_cmd preserving A {
    call malloc [const 20] to [reg A]
    call readLineTerm [reg A] [const 20]
    call printTerminated [reg A]
    call free [reg A]
}

function memdebug_cmd {
    call debugHeap
}

function memdefrag_cmd {
    call defragHeap
}

function alloc_cmd {
    call printTerminated [const :size_str]
    call readWord
    call malloc [stack V]
    call printNewline
    call printTerminated [const :address_str]
    call printWord [stack V]
}

function runinst_cmd preserving A B {
    call malloc [const 50] to [reg A]
    call enterRaw [reg A] to [reg B]
    AD [reg A] [reg B] [reg B]
    MV [const RTA_] [reg mem B]
    FN [reg A]
    call free [reg A]
}

# (start: addr) (end: addr) -- io
function coreDump preserving A B {
    MV [stack S] [reg B]
    MV [stack S] [reg A]

    loop {
        JE [reg A] [reg B] [const :@break]
        MV [reg first mem A] [io]
        MV [reg inc A] [reg A]
    }
}
function readLetter preserving A {
    call readChar to [reg A]
    JN [reg third A] [const _] [const :notletter]
    MV [reg fourth A] [stack V]
    JP [const :@return]

    label notletter
    MV [const ZZZZ] [stack V]
}

# (addr) -- (length (letters))
function enterRaw preserving A B C D {
    MV [stack S] [reg A]
    MV [const 0] [reg D]
    loop {
        call readLetter to [reg B]
        JZ [reg neg B] [const :done]
        MV [reg inc D] [reg D]
        MV [reg first mem A] [reg C]
        ML [reg C] [const A___] [reg C]
        SB [reg mem A] [reg C] [reg mem A]
        ML [reg B] [const A___] [reg B]
        AD [reg mem A] [reg B] [reg mem A]


        MV [reg inc A] [reg A]
    }
    label done
    MV [reg D] [stack V]
}
term_string welcome_str "Welcome to 4LW OS %n"
term_string freemem_str " letters of memory free %n"

term_string entercmd_str "Command: "
term_string address_str "Addr: "
term_string size_str "Size: "
string cmd_buffer "XXXXXXXXXXXXXXXXXXXX"

term_string poke_str "poke"
term_string peek_str "peek"
term_string base27_str "base27"
term_string base10_str "base10"
term_string coredump_str "coredump"
term_string write_str "write"
term_string jump_str "jump"
term_string echo_str "echo"
term_string memdebug_str "memdebug"
term_string memdefrag_str "memdefrag"
term_string runinst_str "runinst"
term_string alloc_str "alloc"
term_string badcmd_str "Bad command"
